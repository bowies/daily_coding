package programmers;

public class 두개_이하로_다른_비트_230311 {
    public long[] solution_쩌는코드(long[] numbers) {

        long[] answer = numbers.clone();
        for(int i = 0; i< answer.length; i++){
            answer[i]++; //x보다 크고니까 +1을 해줌
            answer[i] += (answer[i]^numbers[i])>>2; //오... shift... 2개 shift 해주면 
            //비트 차이1~2개 나는 값 중에 제일 작은 값이 됨
        }
        return answer;

    }

    /*

    제작자의 댓글...
        Super user do!
        answer+1과 answer을 xor(^연산자)하면 나오는 수가 같게? 만드는 수가 되는데 여기서 2개 달라도 된다고 하니 쉬프트로 밀어서 조건을 맞춘다고 해야하나... 그래요...

        Super user do!―2021.10.10 21:21
        Super user do!
        블로그 돌아다니다 제 코드 보고 궁금해 하시는 분 있어서 적어보는데 우선 이 코드 만들게 된 계기가 1~20까지 수기로 답을 찾고 답과 1~20의 숫자랑 비교해서 규칙을 찾아서 수학적으로 만든 코드입니다. 그러다 보니 C,C++,java,Python등 모든 언어에서 작동 가능하다 예상합니다. 그 예상을 뒷받침 해주는데 게가 실제로 C,C#,java,python에 이 풀이법으로 가장 먼저 제출 했으니까요... C++은 역시 고수들이 많아서 저보다 먼저 제출한 사람이 있었지만요...(스위프트나 go쓸줄 알았음 그것도 해서 가장 먼저 제출 했을텐데...)

        Super user do!―2022.02.16 17:49
        Super user do!
        그리고 >>>2 쓰는 이유가 4로 나누는거랑 비슷한 효과(java에선 정수를 나누면 버림으로 계산 하기 때문에)를 가질 수 있어서 /4로 해도 되지만 그냥 비트에 맞춰서 쉬프트로 했습니다.

        Super user do!―2022.02.16 17:51
        Super user do!
        우선 주어진 수 X보다 큰 수 중이기 때문에 최소 +1이상의 수가 필요 하므로 X(풀이에선 answer[i])를 증가시키고

        Super user do!―2022.02.16 17:53
        Super user do!
        X와 X+1을 XOR하면 X를 하나 증가시키면서 변화하는 부분을 캐치가 가능해집니다. 그런데 생각해보면 변화하는 부분이란 X의 비트 1의 자리부터 시작해서 처음으로 0이 나오는 부분까지 밖에 변화가 없으므로

        Super user do!―2022.02.16 17:56
        Super user do!
        0을 바로 찾을 수 있고 모든 비트가 1로 이루어진(1로 이루어졌다고 하지만 0001111 이런 식으로 중간에 0이 안들어간다는 이갸기입니다.)숫자가 나오며

        Super user do!―2022.02.16 17:59
        Super user do!
        이 숫자를 X+1에 더해주면 0 앞에 를 제외한 밑에는 모든 비트가 같아지며 쉬프트를 1번 했을 경우 1개 이하로 다른 비트 2번하면 2개 이하로 다른 비트 3번 하면 3개 이하로 다른 비트가 나오는 형태가 됩니다

        Super user do!―2022.02.16 18:07
        Super user do!
        왜그러냐고요? 저도 잘 몰라요 그냥 이런 규칙성이 있던데요??? ㅋㅋㅋㅋ
        Super user do!―2022.02.16 18:07

     */
}
